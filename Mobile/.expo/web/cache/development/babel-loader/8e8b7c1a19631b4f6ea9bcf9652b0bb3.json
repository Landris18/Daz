{"ast":null,"code":"'use strict';\n\nvar RE_FRAME = /^ {4}at (.+?)(?: \\((native)\\)?| \\((address at )?(.+?):(\\d+):(\\d+)\\))$/;\nvar RE_SKIPPED = /^ {4}... skipping (\\d+) frames$/;\n\nfunction parseLine(line) {\n  var asFrame = line.match(RE_FRAME);\n\n  if (asFrame) {\n    return {\n      type: 'FRAME',\n      functionName: asFrame[1],\n      location: asFrame[2] === 'native' ? {\n        type: 'NATIVE'\n      } : asFrame[3] === 'address at ' ? {\n        type: 'BYTECODE',\n        sourceUrl: asFrame[4],\n        line1Based: Number.parseInt(asFrame[5], 10),\n        virtualOffset0Based: Number.parseInt(asFrame[6], 10)\n      } : {\n        type: 'SOURCE',\n        sourceUrl: asFrame[4],\n        line1Based: Number.parseInt(asFrame[5], 10),\n        column1Based: Number.parseInt(asFrame[6], 10)\n      }\n    };\n  }\n\n  var asSkipped = line.match(RE_SKIPPED);\n\n  if (asSkipped) {\n    return {\n      type: 'SKIPPED',\n      count: Number.parseInt(asSkipped[1], 10)\n    };\n  }\n}\n\nmodule.exports = function parseHermesStack(stack) {\n  var lines = stack.split(/\\n/);\n  var entries = [];\n  var lastMessageLine = -1;\n\n  for (var i = 0; i < lines.length; ++i) {\n    var line = lines[i];\n\n    if (!line) {\n      continue;\n    }\n\n    var entry = parseLine(line);\n\n    if (entry) {\n      entries.push(entry);\n      continue;\n    }\n\n    lastMessageLine = i;\n    entries = [];\n  }\n\n  var message = lines.slice(0, lastMessageLine + 1).join('\\n');\n  return {\n    message: message,\n    entries: entries\n  };\n};","map":{"version":3,"sources":["/home/landris18/Daz/node_modules/react-native/Libraries/Core/Devtools/parseHermesStack.js"],"names":["RE_FRAME","RE_SKIPPED","parseLine","line","asFrame","match","type","functionName","location","sourceUrl","line1Based","Number","parseInt","virtualOffset0Based","column1Based","asSkipped","count","module","exports","parseHermesStack","stack","lines","split","entries","lastMessageLine","i","length","entry","push","message","slice","join"],"mappings":"AAUA;;AAkDA,IAAMA,QAAQ,GAAG,uEAAjB;AAIA,IAAMC,UAAU,GAAG,iCAAnB;;AAEA,SAASC,SAAT,CAAmBC,IAAnB,EAAoD;AAClD,MAAMC,OAAO,GAAGD,IAAI,CAACE,KAAL,CAAWL,QAAX,CAAhB;;AACA,MAAII,OAAJ,EAAa;AACX,WAAO;AACLE,MAAAA,IAAI,EAAE,OADD;AAELC,MAAAA,YAAY,EAAEH,OAAO,CAAC,CAAD,CAFhB;AAGLI,MAAAA,QAAQ,EACNJ,OAAO,CAAC,CAAD,CAAP,KAAe,QAAf,GACI;AAACE,QAAAA,IAAI,EAAE;AAAP,OADJ,GAEIF,OAAO,CAAC,CAAD,CAAP,KAAe,aAAf,GACA;AACEE,QAAAA,IAAI,EAAE,UADR;AAEEG,QAAAA,SAAS,EAAEL,OAAO,CAAC,CAAD,CAFpB;AAGEM,QAAAA,UAAU,EAAEC,MAAM,CAACC,QAAP,CAAgBR,OAAO,CAAC,CAAD,CAAvB,EAA4B,EAA5B,CAHd;AAIES,QAAAA,mBAAmB,EAAEF,MAAM,CAACC,QAAP,CAAgBR,OAAO,CAAC,CAAD,CAAvB,EAA4B,EAA5B;AAJvB,OADA,GAOA;AACEE,QAAAA,IAAI,EAAE,QADR;AAEEG,QAAAA,SAAS,EAAEL,OAAO,CAAC,CAAD,CAFpB;AAGEM,QAAAA,UAAU,EAAEC,MAAM,CAACC,QAAP,CAAgBR,OAAO,CAAC,CAAD,CAAvB,EAA4B,EAA5B,CAHd;AAIEU,QAAAA,YAAY,EAAEH,MAAM,CAACC,QAAP,CAAgBR,OAAO,CAAC,CAAD,CAAvB,EAA4B,EAA5B;AAJhB;AAbD,KAAP;AAoBD;;AACD,MAAMW,SAAS,GAAGZ,IAAI,CAACE,KAAL,CAAWJ,UAAX,CAAlB;;AACA,MAAIc,SAAJ,EAAe;AACb,WAAO;AACLT,MAAAA,IAAI,EAAE,SADD;AAELU,MAAAA,KAAK,EAAEL,MAAM,CAACC,QAAP,CAAgBG,SAAS,CAAC,CAAD,CAAzB,EAA8B,EAA9B;AAFF,KAAP;AAID;AACF;;AAEDE,MAAM,CAACC,OAAP,GAAiB,SAASC,gBAAT,CAA0BC,KAA1B,EAA4D;AAC3E,MAAMC,KAAK,GAAGD,KAAK,CAACE,KAAN,CAAY,IAAZ,CAAd;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,eAAe,GAAG,CAAC,CAAvB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,KAAK,CAACK,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACrC,QAAMtB,IAAI,GAAGkB,KAAK,CAACI,CAAD,CAAlB;;AACA,QAAI,CAACtB,IAAL,EAAW;AACT;AACD;;AACD,QAAMwB,KAAK,GAAGzB,SAAS,CAACC,IAAD,CAAvB;;AACA,QAAIwB,KAAJ,EAAW;AACTJ,MAAAA,OAAO,CAACK,IAAR,CAAaD,KAAb;AACA;AACD;;AAEDH,IAAAA,eAAe,GAAGC,CAAlB;AACAF,IAAAA,OAAO,GAAG,EAAV;AACD;;AACD,MAAMM,OAAO,GAAGR,KAAK,CAACS,KAAN,CAAY,CAAZ,EAAeN,eAAe,GAAG,CAAjC,EAAoCO,IAApC,CAAyC,IAAzC,CAAhB;AACA,SAAO;AAACF,IAAAA,OAAO,EAAPA,OAAD;AAAUN,IAAAA,OAAO,EAAPA;AAAV,GAAP;AACD,CApBD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n'use strict';\n\ntype HermesStackLocationNative = {|\n  +type: 'NATIVE',\n|};\n\ntype HermesStackLocationSource = {|\n  +type: 'SOURCE',\n  +sourceUrl: string,\n  +line1Based: number,\n  +column1Based: number,\n|};\n\ntype HermesStackLocationBytecode = {|\n  +type: 'BYTECODE',\n  +sourceUrl: string,\n  +line1Based: number,\n  +virtualOffset0Based: number,\n|};\n\ntype HermesStackLocation =\n  | HermesStackLocationNative\n  | HermesStackLocationSource\n  | HermesStackLocationBytecode;\n\ntype HermesStackEntryFrame = {|\n  +type: 'FRAME',\n  +location: HermesStackLocation,\n  +functionName: string,\n|};\n\ntype HermesStackEntrySkipped = {|\n  +type: 'SKIPPED',\n  +count: number,\n|};\n\ntype HermesStackEntry = HermesStackEntryFrame | HermesStackEntrySkipped;\n\nexport type HermesParsedStack = {|\n  +message: string,\n  +entries: $ReadOnlyArray<HermesStackEntry>,\n|};\n\n// Capturing groups:\n// 1. function name\n// 2. is this a native stack frame?\n// 3. is this a bytecode address or a source location?\n// 4. source URL (filename)\n// 5. line number (1 based)\n// 6. column number (1 based) or virtual offset (0 based)\nconst RE_FRAME = /^ {4}at (.+?)(?: \\((native)\\)?| \\((address at )?(.+?):(\\d+):(\\d+)\\))$/;\n\n// Capturing groups:\n// 1. count of skipped frames\nconst RE_SKIPPED = /^ {4}... skipping (\\d+) frames$/;\n\nfunction parseLine(line: string): ?HermesStackEntry {\n  const asFrame = line.match(RE_FRAME);\n  if (asFrame) {\n    return {\n      type: 'FRAME',\n      functionName: asFrame[1],\n      location:\n        asFrame[2] === 'native'\n          ? {type: 'NATIVE'}\n          : asFrame[3] === 'address at '\n          ? {\n              type: 'BYTECODE',\n              sourceUrl: asFrame[4],\n              line1Based: Number.parseInt(asFrame[5], 10),\n              virtualOffset0Based: Number.parseInt(asFrame[6], 10),\n            }\n          : {\n              type: 'SOURCE',\n              sourceUrl: asFrame[4],\n              line1Based: Number.parseInt(asFrame[5], 10),\n              column1Based: Number.parseInt(asFrame[6], 10),\n            },\n    };\n  }\n  const asSkipped = line.match(RE_SKIPPED);\n  if (asSkipped) {\n    return {\n      type: 'SKIPPED',\n      count: Number.parseInt(asSkipped[1], 10),\n    };\n  }\n}\n\nmodule.exports = function parseHermesStack(stack: string): HermesParsedStack {\n  const lines = stack.split(/\\n/);\n  let entries = [];\n  let lastMessageLine = -1;\n  for (let i = 0; i < lines.length; ++i) {\n    const line = lines[i];\n    if (!line) {\n      continue;\n    }\n    const entry = parseLine(line);\n    if (entry) {\n      entries.push(entry);\n      continue;\n    }\n    // No match - we're still in the message\n    lastMessageLine = i;\n    entries = [];\n  }\n  const message = lines.slice(0, lastMessageLine + 1).join('\\n');\n  return {message, entries};\n};\n"]},"metadata":{},"sourceType":"script"}